<html>
    <head>
        <title>Fencer lunging</title>
        <style>canvas { width: 100%; height: 100% }</style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script>

            // Sam Hunt 14216618

            // Since there's no abstraction AT ALL for transitions or transformations and everything hinges on the cos wave,
            // We need some pretty massive hacks to do non-co-wave stuff

            // Ideally there would be a way to map transitions to their transformations, and different curve types would be 
            // available to these and linked by a function pointer property inside the transition object etc
            // the updater would pick the right transitions based on the time duration out of the total time 
            // (instead of a proportionate time that goes above 1.0!!!) and apply these in order relative to the node tree

            // Also applying a cos curve globablly to all rotations is terrible for the reason that you can't have multiple
            // parts of the scene which move with different curve types AT THE SAME TIME.
            // We abstract this a bit here by passing in the function we want to use, but its pretty bad without abstracted 
            // transitions...

            // I don't have time to implement this unfortunately due to capstone, so its dirty hack time now sorry. Here we go!!

            var scene = new THREE.Scene();
            scene.name = "Salle d'armes";
            scene.rotates = false;
            var camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 10000);
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            function newBodyPart(name, width, height, depth, rotates, opaque) {
                if (rotates) {
                    var bodyPart = Object.create(new THREE.Object3D());
                }
                else {
                    var geometry = new THREE.BoxGeometry(width, height, depth);
                    var material = new THREE.MeshNormalMaterial({color: 0x00ff00, wireframe : !opaque });
                    var bodyPart = new THREE.Mesh(geometry, material);  
                }
                bodyPart.name = name;
                bodyPart.rotates = rotates;
                bodyPart.offset = function(node, xFraction, yFraction, zFraction) {
                /* Offsets this body part in fractions of the dimensions of the parameter "node".
                   So if node has width 10, height 4, and depth 7, and the fraction parameters are
                   0.5, 0.5, 0.5, then this body part will be offset 5, 2, and 3.5 in x, y and z
                   which would put it at one of the coners of node
                */
                    var xOffset = 0;
                    var yOffset = 0;
                    var zOffset = 0;
                    xOffset = xFraction * node.geometry.parameters.width;
                    yOffset = yFraction * node.geometry.parameters.height;
                    zOffset = zFraction * node.geometry.parameters.depth;
                    /*console.log( "called offset with fractional offsets (" + xFraction + ", " + yFraction + ", " + zFraction + ") "
                         + "and absolute offsets of (" + xOffset  + ", " + yOffset + ", " + zOffset
                         );
                    */
                    this.position.x += xOffset;
                    this.position.y += yOffset;
                    this.position.z += zOffset;
                    }               
                return(bodyPart);
            }

        // MAKE THE BODY PARTS AND JOINTS
            var backFoot      = newBodyPart("Back foot",0.25, 0.25, 0.75, false);  
            var backAnkle     = newBodyPart("Back ankle"    , 0, 0, 0, true);  var backCalf      = newBodyPart ( "Back calf",  0.25,    1, 0.25, false); 
            var backKnee      = newBodyPart("Back knee"     , 0, 0, 0, true);  var backThigh     = newBodyPart ( "Back thigh", 0.35,    1, 0.35, false);    
            var backHip       = newBodyPart("Back hip"      , 0, 0, 0, true);  var torso         = newBodyPart ( "torso",       0.6,    1,  0.4, false); 
            var neck          = newBodyPart("neck"          , 0, 0, 0, true);  var realNeck      = newBodyPart ( "Real neck",   0.3,  0.3,  0.2, false);
                                                                               var head          = newBodyPart ( "Head",        0.4,  0.5, 0.35, false);    
            var frontHip      = newBodyPart("Front hip"     , 0, 0, 0, true);
            var frontHip2     = newBodyPart("Front hip 2"   , 0, 0, 0, true);  var frontThigh   = newBodyPart ( "Front thigh", 0.35,    1, 0.35, false); 
            var frontKnee     = newBodyPart("Front knee"    , 0, 0, 0, true);  var frontCalf    = newBodyPart ( "Front calf",  0.25,    1, 0.25, false); 
            var frontAnkle    = newBodyPart("Front ankle"   , 0, 0, 0, true);  var frontFoot    = newBodyPart ( "Front foot",  0.25, 0.25, 0.75, false);

            var backShoulder  = newBodyPart("Back shoulder" , 0, 0, 0, true);  var backBicep    = newBodyPart ( "Back bicep", 0.25,    1, 0.25, false);
            var backElbow     = newBodyPart("Back elbow"    , 0, 0, 0, true);  var backForearm  = newBodyPart ( "Back forearm",0.2,  0.7,  0.2, false);
            var backWrist     = newBodyPart("Back wrist"    , 0, 0, 0, true);  var backHand     = newBodyPart ( "Back hand",   0.3,  0.3,  0.1, false);

            var frontShoulder = newBodyPart("Front shoulder", 0, 0, 0, true);  var frontBicep   = newBodyPart ("Front bicep",  0.25,   1, 0.25, false);
            var frontElbow    = newBodyPart("Front elbow"   , 0, 0, 0, true);  var frontForearm = newBodyPart ("Front forearm", 0.2, 0.7,  0.2, false);
            var frontWrist    = newBodyPart("Front wrist"   , 0, 0, 0, true);  var frontHand    = newBodyPart ("Front hand",    0.3, 0.3,  0.1, false);
            var frontFingers  = newBodyPart("Front fingers" , 0, 0, 0, true);  

            // Model the sword
            var swordHandle   = newBodyPart ("Sword handle"     ,0.15,  0.5,    0.15,   false, true);
            var swordTang     = newBodyPart ("Sword tang"       ,0.03,  0.5,    0.03,   false, true);
            var swordPommel   = newBodyPart ("Sword pommel"     ,0.18,  0.12,   0.18,   false, true);
            var swordBlade    = newBodyPart ("Sword blade"      ,0.05,  2.25,   0.05,   false, true);
            var swordCoquille = newBodyPart ("Sword coquille"   ,0.4,   0.05,   0.4,    false, true);

        // CONNECT THEM TOGETHER
            
            scene          . add (backFoot    );    backFoot      . add (backAnkle    ); 
            backAnkle      . add (backCalf    );    backCalf      . add (backKnee     );
            backKnee       . add (backThigh   );    backThigh     . add (backHip      );
            backHip        . add (torso       );    torso         . add (neck         );
            neck           . add (realNeck    );
            realNeck       . add (head        );

            neck           . add (head        );    torso         . add (frontHip      );
            frontHip       . add (frontHip2   );
            frontHip2      . add (frontThigh  );    frontThigh    . add (frontKnee    );
            frontKnee      . add (frontCalf   );    frontCalf     . add (frontAnkle   );
            frontAnkle     . add (frontFoot   );   
                                                    torso         . add (backShoulder );
            backShoulder   . add (backBicep   );    backBicep     . add (backElbow    );
            backElbow      . add (backForearm );    backForearm   . add (backWrist    );
            backWrist      . add (backHand    );  
            
                                                    torso         . add (frontShoulder );
            frontShoulder  . add (frontBicep   );   frontBicep    . add (frontElbow    );
            frontElbow     . add (frontForearm );   frontForearm  . add (frontWrist    );
            frontWrist     . add (frontHand    );   frontHand     . add (frontFingers  );
            
            // Create the sword hierarchy
            frontFingers   . add (swordHandle   );
            swordHandle    . add (swordTang     );
            swordHandle    . add (swordCoquille );
            swordTang      . add (swordBlade    );
            swordTang      . add (swordPommel   );


        // POSE THEM
            backFoot      . offset  (backFoot    , -30,     1,    0);      
            backAnkle     .offset (backFoot    ,    0,  0.5, 0.5 ); backCalf       . offset  (backCalf    ,   0,   0.5, -0.5);  
            backKnee      .offset (backCalf    ,    0,  0.5,   0 ); backThigh      . offset  (backThigh   ,   0,   0.5,    0);      
            backHip       .offset (backThigh   ,    0,  0.5,   0 ); torso          . offset  (torso       , 0.3,   0.5,    0);  

            neck          .offset (torso       ,    0,  0.5, 0.25); realNeck       . offset  (realNeck    ,   0,   0.5,    0); 
                                                                    head           . offset  (head        ,   0,  0.75,-0.25);      
            frontHip      .offset (torso       ,  0.3, -0.5,   0 ); 
            frontHip2     .offset (torso       ,    0,    0,   0 );
                                                                      frontThigh   . offset  (frontThigh  ,   0,  -0.5,    0);      
            frontKnee     .offset (frontThigh  ,    0, -0.5,   0 );   frontCalf    . offset  (frontCalf   ,   0,  -0.5,    0);
            frontAnkle    .offset (frontCalf   ,    0, -0.5, 0.5 );   frontFoot    . offset  (frontFoot   ,   0,    -1, -0.5);

            backShoulder  .offset(torso        , -0.5,  0.5,   0 );   backBicep    . offset  (backBicep   , -0.5,  -0.5,    0);
            backElbow     .offset(backBicep    ,    0, -0.5,   0 );   backForearm  . offset  (backForearm ,   0,  -0.5,    0);
            backWrist     .offset(backForearm  ,    0, -0.5,   0 );   backHand     . offset  (backHand    ,   0,  -0.5,    0)

            frontShoulder .offset(torso        ,  0.5,  0.5,   0 );   frontBicep   . offset  (frontBicep  , 0.5,  -0.5,    0);
            frontElbow    .offset(frontBicep   ,    0, -0.5,   0 );   frontForearm . offset  (frontForearm,   0,  -0.5,    0);
            frontWrist    .offset(frontForearm ,    0, -0.5,   0 );   frontHand    . offset  (frontHand   ,   0,  -0.5,    0);
            frontFingers  .offset(frontHand    ,    0, -0.5,   0 );   

            swordHandle     . offset  (swordHandle  ,   0,  0.2,    0);
            swordTang       . offset  (swordTang    ,   0,  0,    0);
            swordCoquille   . offset  (swordHandle  ,   0,  -0.5,    0);
            swordBlade      . offset  (swordTang    ,   0,  -0.5,    0);
            swordBlade      . offset  (swordBlade   ,   0,  -0.5,    0);
            swordPommel     . offset  (swordTang    ,   0,  0.5,    0);
            swordPommel     . offset  (swordPommel  ,   0,  0.5,    0);


        // SPECIFY THE START AND END ANGLES FOR THE INTERPOLATION

            scene         . startRotation    = [    0,    0,    0 ];    scene         . endRotation = [   0,    3,     0];
            backAnkle     . startRotation    = [    0,    0,  -0.2];    backAnkle     . endRotation = [   0,    0,  -1.2]; 
            backKnee      . startRotation    = [  0.2,    0,     0];    backKnee      . endRotation = [   0,    0,     0];
            backHip       . startRotation    = [ -0.3,    0,   0.3];    backHip       . endRotation = [ 0.2,    0,   1.2];
            neck          . startRotation    = [    0,  0.3,     0];    neck          . endRotation = [   0,  0.3,     0]; 
            frontHip      . startRotation    = [    0, -1.3,     0];    frontHip      . endRotation = [   0, -1.3,     0];
            frontHip2     . startRotation    = [  0.4,    0,     0];    frontHip2     . endRotation = [ 1.95,    0,    0];
            frontKnee     . startRotation    = [ -0.3,    0,     0];    frontKnee     . endRotation = [ -1.9,   0,     0];
            frontAnkle    . startRotation    = [ -0.2,    0,     0];    frontAnkle    . endRotation = [-0.1,    0,     0];   
            backShoulder  . startRotation    = [   0,     0,  -0.5];    backShoulder  . endRotation = [   0,    0,  -1.5];
            backElbow     . startRotation    = [    0,    0,  -1.8];    backElbow     . endRotation = [   0,    0,     0];
            backWrist     . startRotation    = [    0,    0,  -1.5];    backWrist     . endRotation = [   0,    0,     0];
            frontShoulder . startRotation    = [    0,    0,   0.5];    frontShoulder . endRotation = [   0,    0,   1.7];
            frontElbow    . startRotation    = [    0,    0,   1.2];    frontElbow    . endRotation = [   0,    0,     0];
            frontWrist    . startRotation    = [    0,    0,     0];    frontWrist    . endRotation = [   0,    0,     0];
            frontFingers  . startRotation    = [    0,    0,   0.1];    frontFingers  . endRotation = [   0,    0,     0];

            // Sword stuff
            swordHandle    . startRotation    = [    0,    0,   0];    swordHandle    . endRotation = [   0,    0,     0];
            swordTang      . startRotation    = [    0,    0,   0];    swordTang      . endRotation = [   0,    0,     0];
            swordCoquille  . startRotation    = [    0,    0,   0];    swordCoquille  . endRotation = [   0,    0,     0];
            swordBlade     . startRotation    = [    0,    0,   0];    swordBlade     . endRotation = [   0,    0,     0];
            swordPommel    . startRotation    = [    0,    0,   0];    swordPommel    . endRotation = [   0,    0,     0];

            // Add the platform
            var geometry = new THREE.BoxGeometry(20, 0.2, 4, 10, 10, 10);
            var material = new THREE.MeshBasicMaterial({color: 0x0f0f0f, wireframe: false});
            var piste = new THREE.Mesh(geometry, material);
            piste.name = "piste";
            piste.rotates = false;
            scene.add(piste);

            // Add a marker for the origin
            var originGeo = new THREE.SphereGeometry(0.3, 6,6);
            var originMat = new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: false});
            var origin = new THREE.Mesh(originGeo, originMat);
            origin.name = "origin";
            origin.rotates = false;
            scene.add(origin);

            camera.position.z = 10;        
            camera.position.y = 1;
            camera.position.x = 0;


            // Define the curves for the animation
            function targetCos(proportion) {
                return (Math.cos(proportion * Math.PI - Math.PI) + 1) / 2;
            }
            function targetLinear(proportion) {
                return proportion;
            }
            function targetParabola(proportion) {
                return proportion * proportion;
            }

            // Define the stages of the animation
            var stages = [
                {
                    stageName   : "Lunges and recovers1",
                    stageInit   : resetSwordParts,
                    stageStart  : 0,
                    stageEnd    : 3000,
                    stageCurve  : targetCos
                },
                {
                    stageName   : "Sword blade falls",
                    stageInit   : detachSwordBlade,
                    stageStart  : 3000,
                    stageEnd    : 4000,
                    stageCurve  : targetParabola
                },
                {
                    stageName   : "Examines sword",
                    stageStart  : 3000,
                    stageEnd    : 6000
                },
                {
                    stageName   : "Sword pommel & tang fall off",
                    stageStart  : 4500,
                    stageEnd    : 5500,
                    stageCurve  : targetParabola
                },
                {
                    stageName   : "Lunges and recovers2",
                    stageStart  : 6000,
                    stageEnd    : 9000,
                    stageCurve  : targetCos
                },
                {
                    stageName   : "Sword coquille falls off",
                    stageStart  : 7500,
                    stageEnd    : 9000,
                    stageCurve  : targetParabola
                }
            ];

            function totalStagesLength() {
                var total = 0;
                for (var i = 0; i < stages.length; i++) {
                    total = Math.max(total, stages[i].stageEnd);
                }
                return total;
            }
            var duration = totalStagesLength();

            function updateStages(currentTime) {
                for (var i = 0; i < stages.length; i++) {
                    total = Math.max(total, stages[i].stageEnd);
                }
            }

            function resetSwordParts() {
                swordTang.detached = false;
                swordCoquille.detached = false;
                swordBlade.detached = false;
                swordPommel.detached = false;
            }

            function detachSwordBlade() {
                swordBlade.detached = true;
            }

            var proportion;

            function intermediateValue(startTime, currentTime, startValue, endValue, targetFunction){
                /* alters the value of a parameter between two limits, 
                   from startValue to endValue and back again, with soft start and soft finish.
                */

                // Its too late for half measures!
                var timeDiff = (currentTime - startTime)%9000;


                if ((timeDiff<3000)||(timeDiff>6000)) {
                    proportion = timeDiff / 1500;
                }


                var target = targetFunction(proportion);
                var intermediateValue = startValue + target * (endValue - startValue);
                return intermediateValue;
            }

            function update(node, nodesToUpdate, level) {

                

                var currentTime = new Date().getTime();

                if  (node.rotates && !node.detached) {
                    if (nodesToUpdate.has("all") || nodesToUpdate.has(node) ) { 
                        node.rotation.x = intermediateValue(startTime, currentTime, node.startRotation[0], node.endRotation[0], targetCos);
                        node.rotation.y = intermediateValue(startTime, currentTime, node.startRotation[1], node.endRotation[1], targetCos);
                        node.rotation.z = intermediateValue(startTime, currentTime, node.startRotation[2], node.endRotation[2], targetCos);
                    }
                    else {
                        node.rotation.x = node.startRotation[0];
                        node.rotation.y = node.startRotation[1];
                        node.rotation.z = node.startRotation[2];
                     }
                }
                var childTally = node.children.length;
                if (childTally > 0) {
                    var listOfChildren = "";
                    for (var i = 0; i < childTally; i++) {
                        listOfChildren = listOfChildren + node.children[i].name + ", " ;
                    }
                    for (var i = 0; i < childTally; i++) {
                        var child = node.children[i];
                        update(child, nodesToUpdate, level + 1);
                    }
                }
            }

            var startTime = new Date().getTime();

            var nodesToUpdate = new Set();
            nodesToUpdate.add("all");

            function render() {
                requestAnimationFrame(render);
                //scene.rotation.y +=0.005;       
                var axis = new THREE.Vector3(1, 0, 0).normalize();
                update(scene, nodesToUpdate, 0);
                renderer.render(scene, camera);
            };
            render();
        </script>
    </body>
</html>
